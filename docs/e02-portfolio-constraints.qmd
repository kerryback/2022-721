---
title:  "Portfolios and CAPM: Portfolio Constraints"
author: <br>Kerry Back<br><br>BUSI 721, Fall 2022<br>JGSB, Rice University
output-dir: docs
execute:
  echo: false
  jupyter: python3
format: 
  revealjs:
    highlight-style: monokai
    code-fold: true
    slide-number: true
    preview-links: true
    self-contained: true
    transition: fade
    theme: [solarized, 721.scss]
    incremental: true
---

#
**There are various reasons to impose ex-ante constraints on portfolio weights.**


<p align=center> <img src="images/mistake-3085712_1920.jpg" height=200 width=300></p>

. . .

:::: {.columns}
::: {.column width="100%"}
- The inputs are **not 100% trustworthy**, so we may want to over-ride extreme allocations.
- We may not want to choose or recommend **a long-term short position** in a major asset class.
- Likewise, we may think we should have at least **some minimum investment** in **some asset classes**.
- There are **costs to short selling** (borrowing fee, limited use of the proceeds) so we may want to **rule it out**.
:::
::::

## No Short Sales

minimize $\frac{\text{A}}{2}w^⊤\text{C}w-x_sr_s+x_br_b-\bar{r}^⊤w$ \

subject to $-x_s \leq 0, -x_b \leq 0, x_s-x_b+1_n^⊤w=1$ \
<p align=center> **and $-w < 0$** </p>

-choice vector: $(x_s,x_b,w)^⊤$ \
-$\text{n} \times \text{n}$ quadratic term with zeros and $\text{AC}$ in bottom right \
-linear term: $(-1,1,-\bar{r})^⊤$ \
-**$\text{n} \times \text{n}$ inequality matrix = -I** \
-$1 \times \text{n}$ equality matrix: (1,-1,1_n) \
-right-hand side of inequality =0's, right-hand side of equality=1 \

#
``` p
rs = 0.04
rb = 0.08

# quadratic and linear terms
Q = np.zeros((5, 5))
Q[2:, 2:] = raver*C
p = np.concatenate(([-rs, rb], -means))

# inequalities
G = - np.identity(5)
h = np.zeros(2)

# equalities
A = np.concatenate(([1, -1], np.ones(3)))
b = np.ones(1)
```
from last session, only changing $\text{G}$
 

# 

``` p
from cvxopt import matrix
from cvxopt.solvers import qp

Q = matrix(Q, (5, 5))
p = matrix(p, (5, 1))
G = matrix(G, (2, 5))
h = matrix(h, (2, 1))
A = matrix(A, (1, 5))
b = matrix(b, (1, 1))

sol = qp(Q, p, G, h, A, b)
xs, xb, w1, w2, w3 = np.array(sol["x"])

```
Same as last session. Solution is the same too for these parameters.

Prohibiting short sales doesn't matter to someone who doesn't want to short anyway.

## How Much do Constraints Matter?

<p align=center> <img src="images/070802_orangutan_hmed_10a.webp" height=200 width=400></p>

:::: {.columns}
::: {.column width="100%"}
- **It depends on the inputs.**
- With **high correlations** and **a large difference in expected returns**, shorting can greatly improve performance.
- When there are many assets (and many errors in inputs) the solver is likely to find two portfolios with high correlations and a large difference in expected returns.
- With a large number of assets, some grouping is normally done before running the optimizer. For example, **optimize over asset classes**.
:::
::::


## Solution from last module

``` p
import numpy as np

# standard deviations
sds = np.array([0.15, 0.25, 0.35])
S = np.diag(sds)

# correlations
r12 = 0.15
r13 = 0.6
r23 = 0.3

R = np.identity(3)
R[0, 1] = R[1, 0] = r12
R[0, 2] = R[2, 0] = r13
R[1, 2] = R[2, 1] = r23

# covariance matrix
C = S @ R @ S

# optimal portfolio
r = 0.04
means = np.array([0.06, 0.1, 0.09])
raver = 4
w = np.linalg.solve(C, (means-r)/raver)
```
Solution is
$\text{w}_1=0.14$ 
$\text{w}_2=0.22$
$\text{w}_3=0.02$ \ 

save 0.62

## Different Borrowing and Saving Rates

$r_{b}=$ borrowing rate > saving rate $= r_{s}$ \ 

$x_{b} \geq 0 =$ amount borrowed \
$x_{s} \geq 0 =$ amount saved


. . .

Portfolio expected return: $$\small x_{s}r_{s}-x_{b}r_{b}+\bar{r}^⊤w$$ \

. . .

Assets=Investments: 

$$\tiny x_{s}+\sum_{i=1}^n w_{i} = 1 + x_{b} \iff x_{s}+1_{n}^⊤w=1+x_{b}$$

## Optimal Portfolios

minimize $\frac{\text{A}}{2}w^⊤\text{C}w-x_{s}r_{s}+x_{b}r_{b}-\bar{r}^⊤w$ \ 

subject to $-x_{s} \leq 0, -x_{b} \leq 0, x_{s}-x{b}+1_n^⊤w=1$

:::: {.columns}
::: {.column width="100%"}
- choice vector: $(x_s,x_b,w)^⊤$
- $(\text{n}+2)\times({\text{n}+2})$ quadratic term with zeros and $\text{AC}$ in bottom right
- linear term: $(-1,1,-\bar{r})^⊤$
- $2 \times \text{(n+2)}$ inequality matrix with rows \
$(-1,0,\cdots,0),(0,-1,0,\cdots,0)$
- $1 \times \text{(n+2)}$ equality matrix: $(1,-1,1_n)$
- right-hand side of inequality = 0's, right-hand side of equality=1
:::
::::

#

``` p
rs = 0.04
rb = 0.08

# quadratic and linear terms
Q = np.zeros((5, 5))
Q[2:, 2:] = raver*C
p = np.concatenate(([-rs, rb], -means))

# inequalities
G = np.zeros((2, 5))
G[0, 0] = G[1, 1] = -1
h = np.zeros(2)

# equalities
A = np.concatenate(([1, -1], np.ones(3)))
b = np.ones(1)
```

## cvxopt

``` p
from cvxopt import matrix
from cvxopt.solvers import qp

Q = matrix(Q, (5, 5))
p = matrix(p, (5, 1))
G = matrix(G, (2, 5))
h = matrix(h, (2, 1))
A = matrix(A, (1, 5))
b = matrix(b, (1, 1))

sol = qp(Q, p, G, h, A, b)
xs, xb, w1, w2, w3 = np.array(sol["x"])
```

Solution is same as in last module for these parameters. Higher borrowing rate doesn't matter for someone who doesn't want to borrow at a lower rate.

## 3K

<p align=center> 
<a href="https://bbcx-investments.com/assets/"><img src="images/Rice_Owl.jpg" alt="HTML tutorial" style="width:4in;"></a>
</p>